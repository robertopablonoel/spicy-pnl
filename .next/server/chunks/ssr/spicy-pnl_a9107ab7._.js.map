{"version":3,"sources":["../../../../../spicy-pnl/node_modules/next/src/server/route-modules/app-page/vendored/contexts/app-router-context.ts","../../../../../spicy-pnl/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-server-dom-turbopack-client.ts","../../../../../spicy-pnl/src/lib/calculations.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['contexts'].AppRouterContext\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactServerDOMTurbopackClient\n","import { Transaction, Account, PLRow, PLSummary, TransactionTag, PLSection } from '@/types';\n\n// Get all transactions for an account (including children)\nexport function getAccountTransactions(\n  accountCode: string,\n  transactions: Transaction[],\n  accounts: Map<string, Account>,\n  tags: Record<string, TransactionTag>,\n  includeTagged: boolean = false\n): Transaction[] {\n  const account = accounts.get(accountCode);\n  if (!account) return [];\n\n  // Get direct transactions\n  let result = transactions.filter(t => {\n    const matchesAccount = t.accountCode === accountCode ||\n      (t.parentAccountCode === accountCode && !accounts.has(t.accountCode));\n    const isTagged = tags[t.id] !== undefined;\n    return matchesAccount && (includeTagged || !isTagged);\n  });\n\n  // Add child account transactions\n  for (const childCode of account.children) {\n    result = result.concat(\n      getAccountTransactions(childCode, transactions, accounts, tags, includeTagged)\n    );\n  }\n\n  return result;\n}\n\n// Calculate monthly amounts for an account\nexport function calculateMonthlyAmounts(\n  accountCode: string,\n  transactions: Transaction[],\n  accounts: Map<string, Account>,\n  months: string[],\n  tags: Record<string, TransactionTag>\n): { monthlyAmounts: Record<string, number>; ytdTotal: number; transactionCount: number } {\n  const accountTransactions = getAccountTransactions(accountCode, transactions, accounts, tags);\n\n  const monthlyAmounts: Record<string, number> = {};\n  months.forEach(m => { monthlyAmounts[m] = 0; });\n\n  let ytdTotal = 0;\n\n  for (const txn of accountTransactions) {\n    if (txn.month && monthlyAmounts[txn.month] !== undefined) {\n      monthlyAmounts[txn.month] += txn.amount;\n      ytdTotal += txn.amount;\n    }\n  }\n\n  return { monthlyAmounts, ytdTotal, transactionCount: accountTransactions.length };\n}\n\n// Build P&L rows for a section\nexport function buildPLRows(\n  section: PLSection,\n  transactions: Transaction[],\n  accounts: Map<string, Account>,\n  months: string[],\n  tags: Record<string, TransactionTag>\n): PLRow[] {\n  const rows: PLRow[] = [];\n\n  // Get top-level accounts for this section\n  const topLevelAccounts = Array.from(accounts.values())\n    .filter(a => a.section === section && a.parentCode === null)\n    .sort((a, b) => a.code.localeCompare(b.code));\n\n  for (const account of topLevelAccounts) {\n    const { monthlyAmounts, ytdTotal, transactionCount } = calculateMonthlyAmounts(\n      account.code, transactions, accounts, months, tags\n    );\n\n    // Only add if there's activity\n    if (ytdTotal !== 0 || transactionCount > 0) {\n      rows.push({\n        accountCode: account.code,\n        account,\n        monthlyAmounts,\n        ytdTotal,\n        transactionCount\n      });\n    }\n  }\n\n  return rows;\n}\n\n// Calculate P&L summary metrics\nexport function calculatePLSummary(\n  transactions: Transaction[],\n  accounts: Map<string, Account>,\n  tags: Record<string, TransactionTag>\n): PLSummary {\n  // Filter out tagged transactions\n  const activeTransactions = transactions.filter(t => !tags[t.id]);\n  const taggedTransactions = transactions.filter(t => tags[t.id]);\n\n  // Calculate by section\n  const bySection = (section: PLSection) =>\n    activeTransactions\n      .filter(t => {\n        const account = accounts.get(t.accountCode);\n        if (!account) return false;\n        // Check if this account or its parent matches the section\n        if (account.section === section) return true;\n        if (t.parentAccountCode) {\n          const parent = accounts.get(t.parentAccountCode);\n          if (parent?.section === section) return true;\n        }\n        return false;\n      })\n      .reduce((sum, t) => sum + t.amount, 0);\n\n  // Revenue breakdown\n  const revenueTransactions = activeTransactions.filter(t => {\n    const code = parseInt(t.accountCode, 10);\n    return code >= 4000 && code < 4100;\n  });\n\n  // Gross revenue (4000 Sales + 4030 Shipping)\n  const grossRevenue = revenueTransactions\n    .filter(t => t.accountCode === '4000' || t.accountCode === '4030')\n    .reduce((sum, t) => sum + t.amount, 0);\n\n  // Contra revenue (discounts, refunds, chargebacks - these are negative)\n  const contraRevenue = revenueTransactions\n    .filter(t => t.accountCode === '4010' || t.accountCode === '4020' || t.accountCode === '4040')\n    .reduce((sum, t) => sum + t.amount, 0);\n\n  const netRevenue = grossRevenue + contraRevenue;\n\n  // Cost sections\n  const totalCOGS = bySection('cogs');\n  const totalCostOfSales = bySection('costOfSales');\n  const totalOpEx = bySection('operatingExpenses');\n  const otherIncome = bySection('otherIncome');\n\n  // Calculated metrics\n  const grossProfit = netRevenue - totalCOGS - totalCostOfSales;\n  const grossMargin = netRevenue !== 0 ? (grossProfit / netRevenue) * 100 : 0;\n  const netIncome = grossProfit - totalOpEx + otherIncome;\n  const netMargin = netRevenue !== 0 ? (netIncome / netRevenue) * 100 : 0;\n\n  // Tagged items - use net amount (not absolute) to match exclusions display\n  const taggedAmount = taggedTransactions.reduce((sum, t) => sum + t.amount, 0);\n\n  return {\n    grossRevenue,\n    netRevenue,\n    totalCOGS,\n    totalCostOfSales,\n    grossProfit,\n    grossMargin,\n    totalOpEx,\n    otherIncome,\n    netIncome,\n    netMargin,\n    taggedItemsCount: taggedTransactions.length,\n    taggedAmount\n  };\n}\n\n// Group transactions by month\nexport function groupTransactionsByMonth(transactions: Transaction[]): Record<string, Transaction[]> {\n  const grouped: Record<string, Transaction[]> = {};\n\n  for (const txn of transactions) {\n    if (!grouped[txn.month]) {\n      grouped[txn.month] = [];\n    }\n    grouped[txn.month].push(txn);\n  }\n\n  // Sort transactions within each month by date\n  for (const month of Object.keys(grouped)) {\n    grouped[month].sort((a, b) => {\n      const dateA = new Date(a.transactionDate);\n      const dateB = new Date(b.transactionDate);\n      return dateA.getTime() - dateB.getTime();\n    });\n  }\n\n  return grouped;\n}\n\n// Get tagged transactions grouped by category and sub-account\nexport function getTaggedTransactionsGrouped(\n  transactions: Transaction[],\n  tags: Record<string, TransactionTag>\n): Record<string, Record<string, Transaction[]>> {\n  const result: Record<string, Record<string, Transaction[]>> = {\n    personal: {},\n    nonRecurring: {}\n  };\n\n  for (const txn of transactions) {\n    const tag = tags[txn.id];\n    if (!tag) continue;\n\n    if (!result[tag.category][tag.subAccount]) {\n      result[tag.category][tag.subAccount] = [];\n    }\n    result[tag.category][tag.subAccount].push(txn);\n  }\n\n  return result;\n}\n\n// Calculate section total for a month\nexport function calculateSectionMonthlyTotal(\n  section: PLSection,\n  transactions: Transaction[],\n  accounts: Map<string, Account>,\n  month: string,\n  tags: Record<string, TransactionTag>\n): number {\n  return transactions\n    .filter(t => {\n      if (tags[t.id]) return false;\n      if (t.month !== month) return false;\n\n      const account = accounts.get(t.accountCode);\n      if (!account) return false;\n\n      if (account.section === section) return true;\n      if (t.parentAccountCode) {\n        const parent = accounts.get(t.parentAccountCode);\n        if (parent?.section === section) return true;\n      }\n      return false;\n    })\n    .reduce((sum, t) => sum + t.amount, 0);\n}\n"],"names":["module","exports","require","vendored","AppRouterContext","ReactServerDOMTurbopackClient"],"mappings":"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","ignoreList":[0,1]}